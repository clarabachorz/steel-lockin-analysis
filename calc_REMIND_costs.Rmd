```{r setup, include = FALSE}
path <- "C:/Users/claraba/Documents/PhD_work/Papers/SteelREMIND/Analysis/"
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(
    root.dir = path
    )


library(ggplot2)
library(gdx)
require(dplyr)
options(dplyr.summarise.inform = FALSE)
library(tidyr)
library(quitte)
library(lusweave)
library(ggsci)
library(pals)
library(stringr)
```

```{R init sets}


###################################################
# CONFIG

name <- "Policy-extended fossil lock-in"


#plotted_years <- c(2030, 2040, 2050)

plotted_regions <- c('EUR', 'CHA', 'USA', 'IND', 'GLO') 
fs = 10 # font size

route_names <- tribble(
  ~route,          ~route_name,
  "bfbof",         "BF-BOF",
  "bfbof_ccs",     "BF-BOF CCS",
  "idreaf_ng_ccs", "DRI-EAF NG CCS",
  "idreaf_ng",     "DRI-EAF NG",
  "idreaf_h2",     "DRI-EAF H2",
  "seceaf",        "Scrap EAF",
  "bfbof_ccs_r",   "BF-BOF CCS retrofit"
)

    
region_names  <- tribble(
  ~region, ~region_name,
  # 'JPN',   'Japan',
  # 'CAZ',   'Australia*'
  'EUR',   'EU',
  'CHA',   'China',
  'USA',   'USA',
  'IND',   'India',
  'GLO',   'Global'
)

```

We first calculate energy costs, using the prices, from which we first have to substract the CO2 price.

```{R load and calculate emiFac}	

calc_emfac <- function(gdx) {

  # emission factors are required to remove the CO2 price from the energy prices
  # these are available for all types of final energy, except electricity and hydrogen
  # for electricity and hydrogen, we need to calculate supply side emissions

  #load all emiFac (fe, se, pe)
  df.emiFac_all <- as.quitte(readGDX(gdx, name="pm_emifac", restore_zeros = F)) %>% 
    filter(all_enty2 == "co2", period %in% t)

  # save the Fe for now
  df.emiFacFe <- df.emiFac_all %>% 
    filter(all_enty1 %in% entyFE) %>%
    select(period, region, all_enty, all_enty1, value) %>%
    rename(entySE = all_enty, entyFE = all_enty1, emiFac = value)

  ### EMI FAC ELEC
  # calculate the emiFac for electricity from the supply side emissions
  # this requires PE emission factors and calculating the PE demand for electricity production

  pe2se <- readGDX(gdx, name="pe2se")

  #emifac for seel
  emifac_seel <- df.emiFac_all %>%
    filter(all_te %in% pe2se$all_te, all_enty1 == "seel") %>%
    select(region, period, value, all_enty, all_te) %>%
    rename(emiFac = value) %>%
    mutate(emiFac = if_else(is.na(emiFac), 0., emiFac))

  #get PE demand for seel
  vm_demPe_seel <- as.quitte(readGDX(gdx, "vm_demPE", field = "l", restore_zeros = F)) %>%
    filter(all_enty1 == "seel", period %in% t) %>%
    select(region, period, all_enty, all_te, value) %>%
    rename(demPe = value)

  #get total SE electricity production
  df.prodSe <- as.quitte(readGDX(gdx, "vm_prodSe", field = "l", restore_zeros = F)) %>%
    filter(all_enty1 == "seel", period %in% t) %>%
    group_by(region, period) %>%
      summarise(prodSe = sum(value)) %>%
      ungroup()

  df_emiPe_seel <- vm_demPe_seel %>%
    left_join(emifac_seel, by=c("region", "period", "all_enty", "all_te")) %>%
    mutate(emiFac = if_else(is.na(emiFac), 0., emiFac)) %>% #change renewables emission factor to 0
    mutate(emiPe = ifelse(demPe != 0, demPe * emiFac, 0.)) %>%
    group_by(region, period) %>%
    summarise(emiPetotal = sum(emiPe)) %>%
      ungroup() %>%
      #add the production of seel to calculate the emission factor
      left_join(df.prodSe, by=c("region", "period")) %>%
      mutate(emiFac = ifelse(prodSe != 0, emiPetotal/prodSe, 0.)) %>%
      select(region, period, emiFac) %>%
      mutate(entyFE = "feels", entySE = "seel")

  ### EMI FAC H2
  # calculate the emiFac for electricity from the supply side emissions
  # this requires PE emission factors and calculating the PE demand for h2 production
  # TODO: likely h2 emission factor also requires elec emiFac

  #emifac for h2
  emifac_h2 <- df.emiFac_all %>%
    filter(all_te %in% pe2se$all_te, all_enty1 == "seh2") %>%
    select(region, period, value, all_enty, all_te) %>%
    rename(emiFac = value) %>%
    mutate(emiFac = if_else(is.na(emiFac), 0., emiFac))

  #get PE demand for h2
  vm_demPe_h2 <- as.quitte(readGDX(gdx, "vm_demPE", field = "l", restore_zeros = F)) %>%
    filter(all_enty1 == "seh2", period %in% t) %>%
    select(region, period, all_enty, all_te, value) %>%
    rename(demPe = value)

  #get total SE h2 production
  df.prodSe <- as.quitte(readGDX(gdx, "vm_prodSe", field = "l", restore_zeros = F)) %>%
    filter(all_enty1 == "seh2", period %in% t) %>%
    group_by(region, period) %>%
      summarise(prodSe = sum(value)) %>%
      ungroup()

  df_emiPe_h2 <- vm_demPe_h2 %>%
    left_join(emifac_h2, by=c("region", "period", "all_enty", "all_te")) %>%
    mutate(emiFac = if_else(is.na(emiFac), 0., emiFac)) %>% #change renewables emission factor to 0
    mutate(emiPe = ifelse(demPe != 0, demPe * emiFac, 0.)) %>%
    group_by(region, period) %>%
    summarise(emiPetotal = sum(emiPe)) %>%
      ungroup() %>%
      #add the production of h2 to calculate the emission factor
      left_join(df.prodSe, by=c("region", "period")) %>%
      mutate(emiFac = ifelse(prodSe != 0, emiPetotal/prodSe, 0.)) %>%
      select(region, period, emiFac) %>%
      mutate(entyFE = "feh2s", entySE = "seh2")

  # combine elec emiFac with the other (FE) emifac
  # not used anymore
  # df.emiFac <- df.emiFacFe %>%
  #   bind_rows(df_emiPe_seel) %>%
  #   bind_rows(df_emiPe_h2)

  #in new code version, we use SE prices, which means we only need the emission factors of elec
  # TODO: add h2 emi fac calculated from elec emi fac and electrolysis efficiency
  df.emiFac <- df_emiPe_seel
  return(df.emiFac)
}
```

```{R calc t&d costs}
#creates function to calculate transmission and distribution costs
# these are only needed for when energy prices are calculated without a Co2 price 
# using SE prices, which do not include t&d costs

calc_td_costs <- function(gdx, df.priceFuel) {

  se2fe <- readGDX(gdx, name="se2fe") %>%
    rename(entySE = all_enty, entyFE = all_enty1, te_td = all_te)

  df.priceFuel <- df.priceFuel %>%
    left_join(se2fe, by=c("entySE","entyFE"))

  td_list <- unique(df.priceFuel$te_td)

  df.capFac <- as.quitte(readGDX(gdx, "vm_capFac", field="l", restore_zeros = F)[,t,]) %>%
      select(region, period, all_te, value) %>%
      filter(all_te %in% td_list ) %>%
      rename(capFac = value)

  wacc <- 0.05

  lifetime <- as.quitte(readGDX(gdx, name="fm_dataglob", restore_zeros = F)[,,"lifetime"][,,][,,"lifetime"]) %>% 
    filter(all_te %in% td_list)

  df.discFac <- lifetime %>%
    select(all_te, value) %>%
    rename(lifetime = value) %>%
    mutate( discFac = wacc * (1+wacc)^lifetime/(-1.+(1+wacc)^lifetime)) %>%
    select(all_te, discFac)

  df.CAPEX <- as.quitte(readGDX(gdx, "vm_costTeCapital", field = "l", restore_zeros = F)[,t,]) %>%
      filter(all_te %in% td_list) %>%
      select(region, period, all_te, value) %>%
      left_join(df.capFac, by=c("region", "period", "all_te")) %>%
      mutate(value = value / capFac) %>%  # conversion from MW/a to MWh/a
      select(-capFac)

  df.OPEX <- as.quitte(readGDX(gdx, "pm_data", restore_zeros = F)[,,"omf"]) %>%
      select(region, all_te, value) %>%
      filter(all_te %in% td_list, value > 0.) %>%
      full_join(df.CAPEX %>% 
                  rename(CAPEX = value) %>%
                  select(region, period, all_te, CAPEX),
                by=c("region", "all_te")) %>%
      mutate(OPEX = value * CAPEX ) %>% 
      select(-CAPEX, -value)
    
  # multiply with discount factor (has to be done after calculating OPEX)
  df.CAPEX <- df.CAPEX %>% 
    left_join(df.discFac, by="all_te") %>% 
    mutate(CAPEX = value * discFac) %>% 
    select(-discFac, -value)

  # eta, transmission efficiency
  df.eta <- as.quitte(readGDX(gdx, "pm_data", restore_zeros = F)[,,"eta"]) %>%
      select(region, all_te, value) %>%
      filter(all_te %in% td_list, value > 0.) %>%
      rename(eta = value)

  df.td_costs <- df.CAPEX %>%
    full_join(df.OPEX, by=c("region", "period", "all_te")) %>%
    left_join(df.eta, by=c("region", "all_te")) %>%
    mutate(td_costs = (CAPEX + OPEX) ) %>%
    select(region, period, all_te, td_costs, eta) %>%
    rename(te_td = all_te)


  df.priceFuel <- df.priceFuel %>%
    left_join(df.td_costs, by=c("region", "period", "te_td")) %>%
    # here, we assume transmission costs are given in terms of incoming energy
    # which means we divide the full price (SEprice + t&d costs) by the efficiency (eta)
    mutate(priceSEtd = (priceSE + td_costs) / eta) %>%
    select(-te_td, -td_costs, -eta, -priceSE) %>%
    #some SE prices have no corresponding FE demand for industry (seliqsyn, sehe, segasyn). remove them
    mutate(priceFuel = priceSEtd * replace_na(SEShare, 0.)) %>% 
    group_by(region, period, entyFE) %>% 
    summarize(priceFuel = sum(priceFuel)) %>%
    ungroup()

  #add FE tax and subsidies

  df.fetax <- as.quitte(readGDX(gdx, name="p21_tau_fe_tax", restore_zeros = F)) %>%
  filter(emi_sectors == "indst", value != 0. ) %>%
  select(region, period, value, all_enty) %>%
  rename(fe_tax = value)

  df.fesub <- as.quitte(readGDX(gdx, name="p21_tau_fe_sub", restore_zeros = F)) %>%
    filter(emi_sectors == "indst", value != 0. ) %>%
    select(region, period, value, all_enty) %>%
    rename(fe_sub = value)

  df.finalfetax <- df.fetax %>%
    full_join(df.fesub, by=c("region", "period", "all_enty")) %>%
    mutate(fe_tax = ifelse(is.na(fe_tax), 0., fe_tax),
          fe_sub = ifelse(is.na(fe_sub), 0., fe_sub)) %>%
    mutate(fe_tax_final = fe_tax + fe_sub) %>%
    select(region, period, all_enty, fe_tax_final) %>%
    rename(entyFE = all_enty)

  df.priceFuel <- df.priceFuel %>%
    left_join(df.finalfetax, by=c("region", "period", "entyFE")) %>%
    mutate(fe_tax_final = ifelse(is.na(fe_tax_final), 0., fe_tax_final),
            priceFuel = priceFuel + fe_tax_final) %>%
    select(-fe_tax_final)

  return(df.priceFuel)
}

```
```{R calculate energy demand and prices}

#calculates energy costs and demand based on a given gdx. 
# can include or exclude co2 price

calc_energy_costs <- function(gdx, include_co2_price = TRUE) {

  # CARBON COST: Carbon price times average emission per FE (which is determined by SE shares, i.e. fossil/bio/synfuel)

  df.priceCO2 <- as.quitte(readGDX(gdx,name=c("p_priceCO2","pm_priceCO2"),format="first_found")) %>%
      select(region, period, value) %>%
      # where carbon price is NA, it is zero
      mutate(value = ifelse(is.na(value), 0, value /1000.)) %>% # carbon price i given in $/tC instead of remind units (tn $/GtC)
      filter(period %in% t) %>%
      rename(priceCO2 = value)

  df.demFe <- as.quitte(readGDX(gdx, "vm_demFeSector_afterTax", field = "l", restore_zeros = F)[,t,]) %>%
    # dimensions: vm_demFeSector_afterTax(ttot,regi,entySE,entyFE,"indst",emiMkt)
    filter(all_enty1 %in% entyFE, emi_sectors == "indst", all_emiMkt == "ETS", value > 0.) %>%
    select(period, region, all_enty, all_enty1, value) %>%
    rename(demFE = value, entySE = all_enty, entyFE = all_enty1)

  df.emiFac <- calc_emfac(gdx)
    
  df.emiFacAvg <- df.demFe %>% 
    left_join(df.emiFac, by=c("region", "period", "entySE", "entyFE")) %>%
    mutate(emiFac = if_else(is.na(emiFac), 0., emiFac), emiTot = demFE * emiFac) %>%
    group_by(period, region, entyFE) %>%
    summarise(emiTot = sum(emiTot), demFE = sum(demFE)) %>%
    ungroup() %>%
    filter(demFE > 0.) %>%
    mutate(emiFac = emiTot / demFE) %>%
    select(-emiTot, -demFE)

  # FE tax per unit of burnt FE (USD/GWa)
  df.FeEmiCost <- df.priceCO2 %>% 
    right_join(df.emiFacAvg, by=c("period", "region")) %>% 
    mutate(FeEmiCost = priceCO2 * emiFac) %>%
    select(-emiFac, -priceCO2)


  #### CALC FUEL PRICES: 
  # 1) include CO2 prices: take price differentiated by SE, then take weighted sum according to SE shares.

  # 2) exclude CO2 prices: take SE prices (which do not include t&d or fuel taxes). 
  # These have no CO2 price for solids, liquids, gases. For elec, subtract CO2 tax.
  if (include_co2_price) {
    df.priceFuel <- as.quitte(readGDX(gdx, "p_FEPrice_by_SE_Sector_EmiMkt", restore_zeros = F)) %>%
      filter(sector == "indst", emiMkt == "ETS", value > 0., period %in% t) %>%
      select(region, period, entySe, all_enty, value) %>%
      rename(entySE = entySe, entyFE = all_enty, priceFuel = value)

    df.demFETotal = df.demFe  %>% 
      group_by( region, period, entyFE) %>% 
      summarize(demFETotal = sum(demFE)) %>%
      ungroup
    df.SEShares = df.demFe  %>%
      left_join(df.demFETotal, by=c("region", "period", "entyFE")) %>%
      mutate(SEShare = demFE / demFETotal) %>%
      select(-demFE, -demFETotal)
    df.priceFuel <- df.priceFuel %>%
      left_join(df.SEShares, by=c("region", "period", "entySE", "entyFE")) %>%
      mutate(priceFuel = priceFuel * replace_na(SEShare, 0.)) %>% 
      group_by(region, period, entyFE) %>% 
      summarize(priceFuel = sum(priceFuel)) %>%
      ungroup

    #prices obtained from SE sector are not available before 2030, so we take pm_FEPrice for these
    df.priceFuel_before_2030 <- as.quitte(readGDX(gdx, "pm_FEPrice", restore_zeros = F)) %>%
      filter(sector == "indst", emiMkt == "ETS", value > 0., period %in% t, period<2030) %>%
      select(region, period, all_enty, value) %>%
      rename(entyFE = all_enty, priceFuel = value)

    df.priceFuel <- df.priceFuel %>%
        bind_rows(df.priceFuel_before_2030)

    df.priceFuel <- df.priceFuel[order(df.priceFuel$period, df.priceFuel$entyFE),]
  }
  else {
    print("Excluding CO2 price from fuel prices. Using SE prices only.")

    df.priceFuel <- as.quitte(readGDX(gdx, "pm_SEPrice", restore_zeros = F)) %>%
      filter(period %in% t) %>%
      select(region, period, all_enty, value) %>%
      rename(entySE = all_enty, priceSE = value)

    df.demFETotal = df.demFe  %>% 
      group_by( region, period, entyFE) %>% 
      summarize(demFETotal = sum(demFE)) %>%
      ungroup

    df.SEShares = df.demFe  %>%
      left_join(df.demFETotal, by=c("region", "period", "entyFE")) %>%
      mutate(SEShare = demFE / demFETotal) %>%
      select(-demFE, -demFETotal)

    df.priceFuel <- df.priceFuel %>%
      left_join(df.SEShares, by=c("region", "period", "entySE")) %>%
      filter(!is.na(entyFE))  #some SE prices have no corresponding FE demand for industry (seliqsyn, sehe, segasyn). remove them

    #add transmission and distribution costs
    df.priceFuel <- calc_td_costs(gdx, df.priceFuel)

    #### Subtract CO2 tax from fuel price (currently only needs ot be done for elec)
    df.priceFuel <- df.priceFuel %>%
      left_join(df.FeEmiCost, by=c("region", "period", "entyFE")) %>%
      mutate(priceFuel = priceFuel - ifelse(is.na(FeEmiCost), 0., FeEmiCost)) %>%
      select(-FeEmiCost)

    }
  ### calculate Fe demand for the different steel routes, and the corresponding FE cost per ton of steel (USD/?t)

  # specFeDem is given in TWa/Gt.
  df.specFeDem <- as.quitte(readGDX(gdx,name=c("pm_specFeDem"),format="first_found",restore_zeros = F)) %>% 
    filter(value > 0., period %in% t) %>%
    select(region, period, all_enty, all_te, opmoPrc, value) %>%
    rename(entyFE = all_enty, specFeDem = value)

  # prices are given in trUSD/TWa,
  # so cost fuel is in trUSD/Gt or USD/t
  df.costFuel <- df.specFeDem %>% 
    left_join(df.priceFuel, by = c("region", "period", "entyFE"))

  df.costFuel <- df.costFuel %>% 
    mutate(value = specFeDem * priceFuel) %>% 
    mutate(component = entyFE) %>% 
    select(-priceFuel, -specFeDem, -entyFE)

  
  return(df.costFuel)
}

```


```{R calculate material costs}

calc_material_costs <- function(gdx) {
  # calculate costs from DRI pellets, iron ore ..
  ###################################################
  # MATERIAL
  # calculates cost of material required
  # for DRIEAF: dri pellets, dri iron. If secondary EAF, additional scrap.
  # for BFBOF: iron ore, pig iron, BOF scrap (very very small)

  #define sets needed
  regi <- readGDX(gdx,"regi")

  #specMatDem is given in t/t
  specMatDem <- as.quitte(readGDX(gdx,name=c("p37_specMatDem"),format="first_found",restore_zeros = F)) %>% 
    filter(value > 0.) %>%
    select(mat, all_te, opmoPrc, value) %>%
    rename( specMatDem = value)

  priceMat <- as.quitte(readGDX(gdx,name=c("p37_priceMat"),format="first_found",restore_zeros = F)) %>% 
    filter(value > 0.) %>%
    select(all_enty, value) %>%
    rename( priceMat = value, mat = all_enty)

  #final costs are in USD/t or trUSD/Gt 
  df.costMat = specMatDem %>% 
    left_join(priceMat, by = "mat") %>% 
    mutate(value = specMatDem * priceMat) %>% 
    filter(value > 0.) %>%
    rename(component = mat) %>% 
    select(-specMatDem, -priceMat) %>%
    crossing(t, regi) %>% 
    rename(period = t, region = regi)
  return(df.costMat)
}
```

```{R calc CAPEX and OPEX}

calc_CAPEX_and_OPEX <- function(gdx){
  #### CALC CAPEX

  #in USD/t capacity
  df.CAPEX <- as.quitte(readGDX(gdx, "vm_costTeCapital", field = "l", restore_zeros = F)[,t,tePrcAll]) %>%
      select(region, period, all_te, value) %>%
      mutate(component = "CAPEX")

  #### CALC OPEX
  # requires capacity factor and O&M costs
  df.capFac <- as.quitte(readGDX(gdx, "vm_capFac", field="l", restore_zeros = F)[,t,]) %>%
      select(region, period, all_te, value) %>%
      filter(all_te %in% tePrcAll ) %>%
      rename(capFac = value)

  df.OMF <- as.quitte(readGDX(gdx, "pm_data", restore_zeros = F)[,,"omf"]) %>%
      select(region, all_te, value) %>%
      filter(all_te %in% tePrcAll, value > 0.) %>%
      # OMF is relative to CAPEX / capfac 
      full_join(df.CAPEX %>% 
                  left_join(df.capFac, by=c("region", "period", "all_te")) %>%
                  mutate(value = value / capFac) %>%  # conversion from MW/a to MWh/a
                  rename(CAPEX = value) %>%
                  select(region, period, all_te, CAPEX),
                by=c("region", "all_te")) %>%
      mutate(value = value * CAPEX ) %>% 
      select(-CAPEX)

  #empty df: no OMV defined for steel production (for now)
  df.OMV <- as.quitte(readGDX(gdx, "pm_data", restore_zeros = F)[,,"omv"]) %>%
      select(region, all_te, value) %>%
      filter(all_te %in% tePrcAll, value > 0.)

  df.OPEX <- bind_rows(df.OMF, df.OMV) %>% 
    group_by( region, period, all_te) %>% 
    summarize(value = sum(value)) %>%
    ungroup  %>%
    mutate(component = "OPEX") %>% 
    full_join(tePrc2opmoPrc, by="all_te")

  return(list(CAPEX = df.CAPEX, OPEX = df.OPEX))
}


```

```{r calc total costs}

calc_cumulative_costs <- function(df, start_year, end_year) {
  full_timesteps <- seq(start_year, end_year, by=5)

  df_expanded <- expand.grid(
    region = unique(df$region),
    period = full_timesteps,
    component = unique(df$component),
    scenario = unique(df$scenario)
  )

  full_df <- df_expanded %>%
    left_join(df, by = c("region", "period", "component", "scenario")) %>%
    group_by(region, component, scenario) %>%
    arrange(period) %>%
    mutate(value = ifelse(is.na(value), lead(value), value)) %>%
    #since the variables are defined such that 2070 = between 2067.5 and 2072.5, we multiply the value by 2.5 for the last year step
    # to get the cumulative value until end_year, not end_year + 2.5
    mutate(value_5_year = ifelse(period == end_year, value * 2.5, value * 5)) %>%
    mutate(cumulative_value = cumsum(value_5_year)) %>%
    ungroup() %>% 
    select(region, period, scenario, component, cumulative_value)

  return(full_df)
}

```

```{R combine costs}
calc_total_costs <- function(gdx, scenario_name, include_co2_price = TRUE, start_year = 2020, end_year = 2070) {
  #### COMBINE COSTS
  # calculate and combine df.costFuel, df.costMat, df.CAPEX, df.OPEX
  # they need to be multiplied either by the production (costs and OPEX) or the capacity additions (CAPEX)
  # all quantities below should be in Gt/a or Gt
  # all the costs are in USD/t, corresponding to trUSD/Gt

  # calculate df.costFuel, df.costMat, df.CAPEX, df.OPEX
  df.costFuel <- calc_energy_costs(gdx, include_co2_price = include_co2_price)
  df.costMat <- calc_material_costs(gdx)
  df.CAPEX_OPEX <- calc_CAPEX_and_OPEX(gdx)
  df.CAPEX <- df.CAPEX_OPEX$CAPEX
  df.OPEX <- df.CAPEX_OPEX$OPEX



  # get yearly production, Gt/a. outflowPrc (2005) is the avg production between 2002.5 and 2007.5
  df.outflowPrc <- as.quitte(readGDX(gdx, "vm_outflowPrc", field = "l", restore_zeros = F)[,t,]) %>%
    filter(all_te %in% tePrcAll) %>%
    select(region, period, all_te, value, opmoPrc) %>%
    rename(outflowPrc = value)

  #vm_delatCap are the annual capacity additions. vm_deltaCap 2005 = annual capacity additions between 2001 and 2005.
  df.deltacap <- as.quitte(readGDX(gdx, "vm_deltaCap", field = "l", restore_zeros = F)[,t,]) %>%
    filter(all_te %in% tePrcAll) %>%
    select(region, period, all_te, value) %>%
    rename(deltacap = value)

  # we have to match vm_deltacap with the standard REMIND variables, ie defining 2005 as 2002.5 -> 2007.5.
  # for this, we need to recalculate df.deltacap.
  # the additions in 2005 are now (3.5* vm_deltacap("2005") + 1.5 * vm_deltacap("2010"))/5 to get the yearly amount
  df.deltacap_new <- df.deltacap %>%
      group_by(region, all_te) %>%
      mutate(deltacap_new = (3.5 * deltacap +1.5*lead(deltacap))/5) %>%
      ungroup() %>%
      mutate(deltacap_new = ifelse(is.na(deltacap_new), deltacap, deltacap_new)) %>% #values for 2100 cant be calculated because there is no 2105 value
      select(-deltacap) %>%
      rename(deltacap = deltacap_new)

  #calc total CAPEX per year (trUSD)
  df.CAPEX_total <- df.CAPEX %>%
    left_join(df.deltacap_new, by=c("region", "period", "all_te")) %>%
    mutate(value = value * deltacap ) %>%
    select(-deltacap) %>%
    group_by(region, period) %>%
      summarise(value = sum(value)) %>%
      ungroup() %>%
      mutate(component = "CAPEX")

  #calc total OPEX, matcost, energy costs per year (trUSD)
  df.OPEX_total <- df.OPEX %>%
    left_join(df.outflowPrc, by=c("region", "period", "all_te", "opmoPrc")) %>%
    mutate(value = value * outflowPrc) %>%
    select(-outflowPrc) %>%
      group_by(region, period) %>%
          summarise(value = sum(value)) %>%
          ungroup() %>%
          mutate(component = "OPEX")

  df.costFuel_total <- df.costFuel %>%
    left_join(df.outflowPrc, by=c("region", "period", "all_te", "opmoPrc")) %>%
    mutate(value = value * outflowPrc) %>%
    select(-outflowPrc) %>%
      group_by(region, period) %>%
          summarise(value = sum(value)) %>%
          ungroup() %>%
          mutate(component = "Energy costs")

  df.costMat_total <- df.costMat %>%
      left_join(df.outflowPrc, by=c("region", "period", "all_te", "opmoPrc")) %>%
      mutate(value = value * outflowPrc) %>%
      select(-outflowPrc) %>%
      group_by(region, period) %>%
          summarise(value = sum(value)) %>%
          ungroup() %>%
          mutate(component = "Materials")

  #costs given in trUSD
  df.totalcosts <- df.CAPEX_total %>%
    bind_rows(df.OPEX_total) %>%
    bind_rows(df.costFuel_total) %>%
    bind_rows(df.costMat_total)

  #add the aggregate global costs
  df.totalglobalcosts <- df.totalcosts %>%
    group_by(period, component) %>%
    summarise(value = sum(value)) %>%
    ungroup() %>%
    mutate(region = "GLO")

  df.totalcosts <- df.totalcosts %>%
    bind_rows(df.totalglobalcosts) %>% 
    mutate(scenario = scenario_name)

  #calculate cumulative costs
  df.cumulativecosts <- calc_cumulative_costs(df.totalcosts, start_year = start_year, end_year = end_year)

  return(list(yearly = df.totalcosts, cumu = df.cumulativecosts))
}
```
```{r load gdx}
gdx <- "inputdata/gdx/650_govtargets.gdx"
```

```{r load sets}
#define sets required (they are the same across all gdx files)
tePrc <- readGDX(gdx,"tePrc")
tePrcAll <- tePrc

tePrc2opmoPrc <- as.data.frame(readGDX(gdx,"tePrc2opmoPrc")) %>% 
  rename(all_te = tePrc)

entyFE <- as.vector(readGDX(gdx, name="entyFE"))

t <- readGDX(gdx,"ttot")
t <- as.numeric(t[t >= 2010 & t <= 2100])
```

```{r calculate costs}
# greenpol <- "inputdata/gdx/GreenPolicyEarlyReti-PkBudg650.gdx"
# base <- "inputdata/gdx/PolicyExtended-PkBudg650.gdx"

greenpol <- "inputdata/gdx/GreenPolicyEarlyReti_regPol-PkBudg1000.gdx"
base <- "inputdata/gdx/PolicyExtended_regPol-PkBudg1000.gdx"
#calculate costs
df.totalcosts1 <- calc_total_costs(greenpol, scenario_name = "greenpol", include_co2_price = FALSE, start_year = 2025, end_year = 2070)

df.totalcosts2 <- calc_total_costs(base, scenario_name = "base", include_co2_price = FALSE, start_year = 2025, end_year = 2070)

# print(df.totalcosts$cumu %>% filter(region == "IND"), n=Inf)

# print(df.totalcosts$cumu %>% filter(region == "IND"), n=Inf)


```

```{R tests}
df.totalcosts <- bind_rows(df.totalcosts1$cumu, df.totalcosts2$cumu) %>%
  pivot_wider(names_from = scenario, values_from = cumulative_value) %>% 
  mutate(diff_scenarios = `greenpol` - `base`) %>%
  mutate(perc_diff_scenarios = diff_scenarios / (`base` + `greenpol`) * 100)

df.totalcosts_aggr <- df.totalcosts %>%
  group_by(region, period) %>%
  summarise(total_greenpol = sum(greenpol),
            total_base = sum(base)) %>%
  mutate(diff_scenarios = total_greenpol - total_base) %>%
  mutate(perc_diff_scenarios = diff_scenarios / (total_base + total_greenpol) * 100) %>% 
  select(-total_greenpol, -total_base)

plot_df <- df.totalcosts %>%
  filter(region %in% plotted_regions) %>%
  mutate(region = factor(region, levels = plotted_regions, labels = region_names$region_name)) %>%
  mutate(period = as.numeric(period)) %>% 
  select(-greenpol, - base)

# print(df.totalcosts_plot %>% filter(region == "IND"), n=Inf)
```

```{r plot costs}

component_order <- c("CAPEX", "OPEX","Materials", "Energy costs")

plot_df <- plot_df %>%
  mutate(
    period = as.integer(period),
    component = factor(component, levels = component_order)
  )


#filter global and non global results
plot_df_global <- plot_df %>% filter(region == "Global")
plot_df_others <- plot_df %>% filter(region != "Global")


# Area plot
region_plot <- ggplot(plot_df_others, aes(x = period, y = diff_scenarios, fill = component)) +
  geom_area(position = "stack", alpha = 0.5) +
  stat_summary(aes(group = 1),fun = sum, geom = "line", color = "black", size = 1) +
  # to add a smooth line on top
  #geom_smooth(aes(color = component), method = "loess", se = FALSE, size = 0.8, linetype = "dashed") +
  facet_wrap(~ region, scales = "free_y") +
  labs(
    title = "",
    x = "Year",
    y = "Cumulative cost difference\n(trUSD)",
    fill = "Component"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.minor = element_blank(),
    strip.text = element_text(face = "bold"),
    legend.position = "bottom",
  )

global_plot <- ggplot(plot_df_global, aes(x = period, y = diff_scenarios, fill = component)) +
  geom_area(position = "stack", alpha = 0.5) +
  stat_summary(aes(group = 1),fun = sum, geom = "line", color = "black", size = 1) +
  # to add a smooth line on top
  #geom_smooth(aes(color = component), method = "loess", se = FALSE, size = 0.8, linetype = "dashed") +
  facet_wrap(~ region, scales = "free_y") +
  labs(
    title = "Cumulative cost difference between the green policy and base scenarios\nfor the well-below 2°C target scenarios with regional net-zero targets",
    x = "Year",
    y = "Cumulative cost difference\n(trUSD)",
    fill = "Component"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.minor = element_blank(),
    strip.text = element_text(face = "bold"),
    legend.position = "none",
    plot.margin=unit(c(1,1,-0.5,1), "cm")
  ) +
  #add arrow at 2020 and annotation
  annotate("segment", x = 2025, xend = 2025, y = 0, yend = max(plot_df_global$diff_scenarios), arrow = arrow(length = unit(0.2, "cm")), color = "#797777")+
  geom_text(aes(x = 2029, y = max(plot_df_global$diff_scenarios) * 0.9, label = "Green policy more expensive\nthan base transition"), color = "#797777", size = 4, hjust =0.3) +
  annotate("segment", x = 2025, xend = 2025, y = 0, yend = -max(plot_df_global$diff_scenarios)*3, arrow = arrow(length = unit(0.2, "cm")), color = "#797777")+
  geom_text(aes(x = 2029, y = -max(plot_df_global$diff_scenarios) * 2.5, label = "Green policy less expensive\nthan base transition"), color = "#797777", size = 4, hjust =0.3)

final_plot <- gridExtra::grid.arrange(global_plot,region_plot,  ncol = 1)

print(final_plot)
#save
# ggsave("figs_temp/costs_greenpol_vs_base_1000_reg.png", plot = final_plot, width = 10, height = 12, dpi = 300)
# ggsave("figs_temp/costs_greenpol_vs_NPi_1000_reg.png", plot = final_plot, width = 10, height = 12, dpi = 300)
```

```{r calculate costs}

greenpol <- "inputdata/gdx/GreenPolicyEarlyReti-PkBudg650.gdx"
npi <- "inputdata/gdx/GreenPolicyEarlyReti-NPi.gdx"
#calculate costs
df.totalcosts1 <- calc_total_costs(greenpol, scenario_name = "greenpol", include_co2_price = FALSE, start_year = 2025, end_year = 2070)

df.totalcosts2 <- calc_total_costs(npi, scenario_name = "npi", include_co2_price = FALSE, start_year = 2025, end_year = 2070)

# print(df.totalcosts$cumu %>% filter(region == "IND"), n=Inf)

# print(df.totalcosts$cumu %>% filter(region == "IND"), n=Inf)


```

```{R tests}
df.totalcosts <- bind_rows(df.totalcosts1$cumu, df.totalcosts2$cumu) %>%
  pivot_wider(names_from = scenario, values_from = cumulative_value) %>% 
  mutate(diff_scenarios = `greenpol` - `npi`) %>%
  mutate(perc_diff_scenarios = diff_scenarios / (`npi` + `greenpol`) * 100)

df.totalcosts_aggr <- df.totalcosts %>%
  group_by(region, period) %>%
  summarise(total_greenpol = sum(greenpol),
            total_npi = sum(npi)) %>%
  mutate(diff_scenarios = total_greenpol - total_npi) %>%
  mutate(perc_diff_scenarios = diff_scenarios / (total_npi + total_greenpol) * 100) %>% 
  select(-total_greenpol, -total_npi)

plot_df <- df.totalcosts %>%
  filter(region %in% plotted_regions) %>%
  mutate(region = factor(region, levels = plotted_regions, labels = region_names$region_name)) %>%
  mutate(period = as.numeric(period)) %>% 
  select(-greenpol, - npi)

# print(df.totalcosts_plot %>% filter(region == "IND"), n=Inf)
```

```{r plot costs}

component_order <- c("CAPEX", "OPEX","Materials", "Energy costs")

plot_df <- plot_df %>%
  mutate(
    period = as.integer(period),
    component = factor(component, levels = component_order)
  )


#filter global and non global results
plot_df_global <- plot_df %>% filter(region == "Global")
plot_df_others <- plot_df %>% filter(region != "Global")


# Area plot
region_plot <- ggplot(plot_df_others, aes(x = period, y = diff_scenarios, fill = component)) +
  geom_area(position = "stack", alpha = 0.5) +
  stat_summary(aes(group = 1),fun = sum, geom = "line", color = "black", size = 1) +
  # to add a smooth line on top
  #geom_smooth(aes(color = component), method = "loess", se = FALSE, size = 0.8, linetype = "dashed") +
  facet_wrap(~ region, scales = "free_y") +
  labs(
    title = "",
    x = "Year",
    y = "Cumulative cost difference\n(trUSD)",
    fill = "Component"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.minor = element_blank(),
    strip.text = element_text(face = "bold"),
    legend.position = "bottom",
  )

global_plot <- ggplot(plot_df_global, aes(x = period, y = diff_scenarios, fill = component)) +
  geom_area(position = "stack", alpha = 0.5) +
  stat_summary(aes(group = 1),fun = sum, geom = "line", color = "black", size = 1) +
  # to add a smooth line on top
  #geom_smooth(aes(color = component), method = "loess", se = FALSE, size = 0.8, linetype = "dashed") +
  facet_wrap(~ region, scales = "free_y") +
  labs(
    title = "Cumulative cost difference between the green policy runs\n between an NPi and a 1.5°C target scenario",
# title = "Cumulative cost difference between the green policy runs\n between an NPi and a well-below 2°C target scenario",
    x = "Year",
    y = "Cumulative cost difference\n(trUSD)",
    fill = "Component"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.minor = element_blank(),
    strip.text = element_text(face = "bold"),
    legend.position = "none",
    plot.margin=unit(c(1,1,-0.5,1), "cm")
  ) +
  #add arrow at 2020 and annotation
  annotate("segment", x = 2025, xend = 2025, y = 0, yend = max(plot_df_global$diff_scenarios), arrow = arrow(length = unit(0.2, "cm")), color = "#797777")+
  geom_text(aes(x = 2029, y = max(plot_df_global$diff_scenarios) * 0.7, label = "Climate target\nscenario more expensive\nthan NPi"), color = "#797777", size = 4, hjust =0.3) +
  annotate("segment", x = 2025, xend = 2025, y = 0, yend = -max(plot_df_global$diff_scenarios), arrow = arrow(length = unit(0.2, "cm")), color = "#797777")+
  geom_text(aes(x = 2029, y = -max(plot_df_global$diff_scenarios) * 0.7, label = "Climate target\nscenario less expensive\nthan NPi"), color = "#797777", size = 4, hjust =0.3)

final_plot <- gridExtra::grid.arrange(global_plot,region_plot,  ncol = 1)

print(final_plot)
#save
ggsave("figs_temp/costs_greenpol_NPi_vs_650.png", plot = final_plot, width = 10, height = 12, dpi = 300)
```


